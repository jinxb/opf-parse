'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var Promise = _interopDefault(require('bluebird'));
var xml2js = _interopDefault(require('xml2js'));
var _ = _interopDefault(require('lodash'));
var fs = _interopDefault(require('fs'));

const readFile = Promise.promisify(fs.readFile);
const writeFile = Promise.promisify(fs.writeFile);

function assert(condition, message) {
  if (!condition) {
    throw new Error(message);
  }
}

const OPF_DEFAULT = {
  package: {
    $: {
      xmlns: 'http://www.idpf.org/2007/opf',
      version: '2.0'
    },
    metadata: [{
      $: {
        'xmlns:dc': 'http://purl.org/dc/elements/1.1/',
        'xmlns:opf': 'http://www.idpf.org/2007/opf'
      }
    }]
  }
};



const OPF_ROLES = {
  adp: {
    name: 'Adapter',
    description: 'Use for a person who 1) reworks a musical composition, usually for a different medium, or 2) rewrites novels or stories for motion pictures or other audiovisual medium.'
  },
  ann: {
    name: 'Annotator',
    description: 'Use for a person who writes manuscript annotations on a printed item.'
  },
  arr: {
    name: 'Arranger',
    description: 'Use for a person who transcribes a musical composition, usually for a different medium from that of the original; in an arrangement the musical substance remains essentially unchanged.'
  },
  art: {
    name: 'Artist',
    description: 'Use for a person (e.g., a painter) who conceives, and perhaps also implements, an original graphic design or work of art, if specific codes (e.g., [egr], [etr]) are not desired. For book illustrators, prefer Illustrator [ill].'
  },
  asn: {
    name: 'Associated name',
    description: 'Use as a general relator for a name associated with or found in an item or collection, or which cannot be determined to be that of a Former owner [fmo] or other designated relator indicative of provenance.'
  },
  aut: {
    name: 'Author',
    description: 'Use for a person or corporate body chiefly responsible for the intellectual or artistic content of a work. This term may also be used when more than one person or body bears such responsibility.'
  },
  aqt: {
    name: 'Author in quotations or text extracts',
    description: 'Use for a person whose work is largely quoted or extracted in a works to which he or she did not contribute directly. Such quotations are found particularly in exhibition catalogs, collections of photographs, etc.'
  },
  aft: {
    name: 'Author of afterword, colophon, etc.',
    description: 'Use for a person or corporate body responsible for an afterword, postface, colophon, etc. but who is not the chief author of a work.'
  },
  aui: {
    name: 'Author of introduction, etc.',
    description: 'Use for a person or corporate body responsible for an introduction, preface, foreword, or other critical matter, but who is not the chief author.'
  },
  ant: {
    name: 'Bibliographic antecedent',
    description: 'Use for the author responsible for a work upon which the work represented by the catalog record is based. This can be appropriate for adaptations, sequels, continuations, indexes, etc.'
  },
  bkp: {
    name: 'Book producer',
    description: 'Use for the person or firm responsible for the production of books and other print media, if specific codes (e.g., [bkd], [egr], [tyd], [prt]) are not desired.'
  },
  clb: {
    name: 'Collaborator',
    description: 'Use for a person or corporate body that takes a limited part in the elaboration of a work of another author or that brings complements (e.g., appendices, notes) to the work of another author.'
  },
  cmm: {
    name: 'Commentator',
    description: 'Use for a person who provides interpretation, analysis, or a discussion of the subject matter on a recording, motion picture, or other audiovisual medium. Compiler [com] Use for a person who produces a work or publication by selecting and putting together material from the works of various persons or bodies.'
  },
  dsr: {
    name: 'Designer',
    description: 'Use for a person or organization responsible for design if specific codes (e.g., [bkd], [tyd]) are not desired.'
  },
  edt: {
    name: 'Editor',
    description: 'Use for a person who prepares for publication a work not primarily his/her own, such as by elucidating text, adding introductory or other critical matter, or technically directing an editorial staff.'
  },
  ill: {
    name: 'Illustrator',
    description: 'Use for the person who conceives, and perhaps also implements, a design or illustration, usually to accompany a written text.'
  },
  lyr: {
    name: 'Lyricist',
    description: 'Use for the writer of the text of a song.'
  },
  mdc: {
    name: 'Metadata contact',
    description: 'Use for the person or organization primarily responsible for compiling and maintaining the original description of a metadata set (e.g., geospatial metadata set).'
  },
  mus: {
    name: 'Musician',
    description: 'Use for the person who performs music or contributes to the musical content of a work when it is not possible or desirable to identify the function more precisely.'
  },
  nrt: {
    name: 'Narrator',
    description: 'Use for the speaker who relates the particulars of an act, occurrence, or course of events.'
  },
  oth: {
    name: 'Other',
    description: 'Use for relator codes from other lists which have no equivalent in the MARC list or for terms which have not been assigned a code.'
  },
  pht: {
    name: 'Photographer',
    description: 'Use for the person or organization responsible for taking photographs, whether they are used in their original form or as reproductions.'
  },
  prt: {
    name: 'Printer',
    description: 'Use for the person or organization who prints texts, whether from type or plates.'
  },
  red: {
    name: 'Redactor',
    description: 'Use for a person who writes or develops the framework for an item without being intellectually responsible for its content.'
  },
  rev: {
    name: 'Reviewer',
    description: 'Use for a person or corporate body responsible for the review of book, motion picture, performance, etc.'
  },
  spn: {
    name: 'Sponsor',
    description: 'Use for the person or agency that issued a contract, or under whose auspices a work has been written, printed, published, etc.'
  },
  ths: {
    name: 'Thesis advisor',
    description: 'Use for the person under whose supervision a degree candidate develops and presents a thesis, memoir, or text of a dissertation.'
  },
  trc: {
    name: 'Transcriber',
    description: 'Use for a person who prepares a handwritten or typewritten copy from original material, including from dictated or orally recorded material.'
  },
  trl: {
    name: 'Translator',
    description: 'Use for a person who renders a text from one language into another, or from an older form of a language into the modern form.'
  }
};

const NAME_TO_OPF_CODE = {
  Adapter: 'adp',
  Annotator: 'ann',
  Arranger: 'arr',
  Artist: 'art',
  'Associated name': 'asn',
  Author: 'aut',
  'Author in quotations or text extracts': 'aqt',
  'Author of afterword, colophon, etc.': 'aft',
  'Author of introduction, etc.': 'aui',
  'Bibliographic antecedent': 'ant',
  'Book producer': 'bkp',
  Collaborator: 'clb',
  Commentator: 'cmm',
  Designer: 'dsr',
  Editor: 'edt',
  Illustrator: 'ill',
  Lyricist: 'lyr',
  'Metadata contact': 'mdc',
  Musician: 'mus',
  Narrator: 'nrt',
  Other: 'oth',
  Photographer: 'pht',
  Printer: 'prt',
  Redactor: 'red',
  Reviewer: 'rev',
  Sponsor: 'spn',
  'Thesis advisor': 'ths',
  Transcriber: 'trc',
  Translator: 'trl'
};

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

const simpleTransform = {
  assert: values => assert(Array.isArray(values) && values.every(e => typeof e === 'string'), `${values} must be set with an array of strings!`),
  iteratee: t => typeof t === 'object' ? t._ : t,
  inverseIteratee: (t, defaultAttrs) => defaultAttrs ? { $: defaultAttrs, _: t } : t
};

const metaTagsMap = {
  toObject: meta => meta.reduce((p, v) => {
    const { name, content } = v.$;
    const result = name.match(/^(\w+):(\S+)/);
    let namespace = 'defaults';
    let attr = name;
    if (result !== null) {
      namespace = result[1];
      attr = _.camelCase(result[2]);
    }
    if (p[namespace]) {
      p[namespace][attr] = content;
    } else {
      p[namespace] = { [attr]: content };
    }
    return p;
  }, {}),
  fromObject: meta => _.flatMap(meta, (attrs, namespace) => {
    const namespaced = namespace === 'defaults' ? '' : `${namespace}:`;
    return _.map(attrs, (value, attr) => ({
      $: {
        name: `${namespaced}${_.snakeCase(attr)}`,
        content: JSON.stringify(value)
      }
    }));
  })
};

// returns object representing the xml element
const opfTransform = {
  assert: values => assert(Array.isArray(values) && values.every(e => typeof e === 'string' || typeof e === 'object' && typeof e.value === 'string'), `${values} must be set with an array of strings and/or objects { value, attrs... }!`),
  iteratee: t => {
    if (typeof t !== 'object') {
      return { value: t };
    }
    const data = Object.keys(t.$).reduce((p, attr) => {
      const value = t.$[attr];
      const result = attr.match(/^(\w+):(\S+)/);
      if (result === null) {
        if (!p.defaults) p.defaults = { [attr]: value };else p.defaults[attr] = value;
        return p;
      }
      const namespace = result[1];
      const attribute = _.camelCase(result[2]);
      if (namespace === 'opf') {
        p[attribute] = attribute === 'role' ? OPF_ROLES[value].name : value;
      } else if (!p[namespace]) {
        p[namespace] = { [attribute]: value };
      } else {
        p[namespace][attribute] = value;
      }
      return p;
    }, { value: t._ });
    return data;
  },
  inverseIteratee: (t, defaultAttrs) => {
    if (typeof t === 'string') return { _: t, $: defaultAttrs };
    const data = { _: t.value };
    const attributes = Object.keys(t).reduce((p, v) => {
      if (v === 'value') return p;
      const value = t[v];
      if (typeof value === 'object' && value !== undefined) {
        const namespace = v === 'defaults' ? '' : `${v}:`;
        Object.keys(value).forEach(attr => {
          p[`${namespace}${_.kebabCase(attr)}`] = value[attr];
        });
      } else {
        p[`opf:${_.kebabCase(v)}`] = v === 'role' ? NAME_TO_OPF_CODE[value] || 'aut' : value;
      }
      return p;
    }, {});
    data.$ = _extends({}, defaultAttrs, attributes);
    return data;
  }
};

/*
 * OPF metadata handling
 * Ability to do basic reading and writing of Calibre's opf (xml) metadata format
 */
const parseStringAsync = Promise.promisify(xml2js.parseString);

const builder = new xml2js.Builder();

// Extracted Opf metadata gets packaged into an OPF
class OPF {
  constructor(parsedXmlData) {
    const parsedXmlDataToUse = parsedXmlData || _.cloneDeep(OPF_DEFAULT);
    this.data = parsedXmlDataToUse;
    this.metadata = this.data.package.metadata[0];
    this.guide = _.get(this.data, 'package.guide[0]');
    this.metaTags = undefined;
  }

  get cover() {
    if (!this.guide || !this.guide.reference) return undefined;
    const v = this.guide.reference.find(ref => typeof ref.$.type === 'string' && ref.$.type.toLowerCase() === 'cover');
    return v.$.href;
    // return;
  }

  set cover(src) {
    if (!this.guide) {
      this.guide = {};
    }
    if (!this.guide.reference) {
      this.guide.reference = [];
    }
    const v = this.guide.reference.find(ref => typeof ref.$.type === 'string' && ref.$.type.toLowerCase() === 'cover');
    if (v) v.$.href = src;else {
      this.guide.reference.push({ $: {
          type: 'cover',
          title: 'Cover',
          href: src
        } });
    }
  }

  merge(obj) {
    _.each(obj, (value, key) => {
      const description = Object.getOwnPropertyDescriptor(OPF.prototype, key);
      if (description && description.set) {
        this[key] = value;
      } else {
        console.warn('Can’t set', key, 'because OPF has no setter method associated with that key');
      }
    });
  }

  get meta() {
    if (this.metaTags) return this.metaTags;
    if (this.metadata.meta === undefined) return undefined;
    this.metaTags = metaTagsMap.toObject(this.metadata.meta);
    return this.metaTags;
  }

  set meta(obj) {
    // modify internal state
    this.metaTags = obj;
  }

  get uniqueIdentifierKey() {
    return this.data.package.$['unique-identifier'];
  }

  set uniqueIdentifierKey(value) {
    if (!this.data.package.$) this.data.package.$ = { 'unique-identifier': value };else this.data.package.$['unique-identifier'] = value;
  }

  get date() {
    // TODO:
    // opf-event data should be fetched as well.
    // detect and convert to date object (YYYY[-MM[-DD]])
    const field = this.metadata['dc:date'];
    return field ? new Date(this.metadata['dc:date'][0]) : undefined;
  }

  set date(date) {
    // TODO:
    // opf-event data should be fetched as well.
    // detect and convert to date object (YYYY[-MM[-DD]])
    this.metadata['dc:date'] = [date.toISOString()];
  }

  get identifiers() {
    const field = this.metadata['dc:identifier'];
    return field ? field.map(v => {
      const transformed = opfTransform.iteratee(v);
      if (v.$.id === this.uniqueIdentifierKey) transformed.id = this.uniqueIdentifierKey;
      return transformed;
    }) : undefined;
  }

  set identifiers(ids) {
    assert(Array.isArray(ids) && ids.every(id => typeof id === 'object' && id.scheme !== undefined && id.value !== undefined), 'identifiers must be set with an array of objects with scheme and value keys');
    const uuidIndex = ids.findIndex(id => id.id); // find id with id key
    assert(uuidIndex !== -1, 'At least one identifier must contain truthy id key');
    this.uniqueIdentifierKey = `${ids[uuidIndex].scheme}_id`;
    this.metadata['dc:identifier'] = ids.map((v, i) => {
      if (i === uuidIndex) {
        delete v.id;
        if (v.defaults) v.defaults.id = this.uniqueIdentifierKey;else v.defaults = { id: this.uniqueIdentifierKey };
      }
      return opfTransform.inverseIteratee(v);
    });
  }

  toXML() {
    if (this.metaTags) {
      // reinject metaTags back into xml structure before building
      this.metadata.meta = metaTagsMap.fromObject(this.metaTags);
    }
    if (this.metadata) this.data.package.metadata = [this.metadata];
    if (this.guide) this.data.package.guide = [this.guide];
    return builder.buildObject(this.data);
  }
}

// Attach getter and setters to OPF programmatically based on expected metadata;

const simpleDublinCoreProperties = ['title', 'description', 'type', 'format', 'coverage', 'rights', 'source'];

const multipleDublinCoreProperties = [{
  property: 'title',
  alias: 'titles'
}, {
  property: 'creator',
  alias: 'authors',
  transform: opfTransform,
  defaultAttrs: { 'opf:role': 'aut' }
}, {
  property: 'contributor',
  alias: 'contributors',
  transform: opfTransform,
  defaultAttrs: { 'opf:role': 'clb' }
}, {
  property: 'subject',
  alias: 'subjects'
}, {
  property: 'publisher',
  alias: 'publishers'
}, {
  property: 'language',
  alias: 'languages'
}];

// TODO: add simple cache for gotten item that is updated on set
simpleDublinCoreProperties.forEach(property => {
  const dcProperty = `dc:${property}`;
  function set(value) {
    assert(typeof value === 'string', `${dcProperty} must be set with a string!`);
    if (!Array.isArray(this.metadata[dcProperty])) {
      this.metadata[dcProperty] = [value];
    } else {
      this.metadata[dcProperty][0] = value;
    }
  }
  function get() {
    const field = this.metadata[dcProperty];
    return field ? field[0] : undefined;
  }
  Object.defineProperty(OPF.prototype, property, { get, set });
});

multipleDublinCoreProperties.forEach(({ property, alias, transform = simpleTransform, defaultAttrs }) => {
  const dcProperty = `dc:${property}`;
  function set(values) {
    transform.assert(values);
    this.metadata[dcProperty] = values.map(v => transform.inverseIteratee(v, defaultAttrs));
  }
  function get() {
    const field = this.metadata[dcProperty];
    return field ? field.map(transform.iteratee) : undefined;
  }
  Object.defineProperty(OPF.prototype, alias, { get, set });
});

// Parses an opf file
function readOPF(fileLoc, encoding = 'utf-8') {
  return readFile(fileLoc, encoding).then(data => parseStringAsync(data)).then(xml => new OPF(xml));
}

// Writes an opf file from an OPF object
function writeOPF(fileLoc, opf) {
  return writeFile(fileLoc, opf.toXML());
}

exports.OPF = OPF;
exports.readOPF = readOPF;
exports.writeOPF = writeOPF;
